📦 2. Field ko private kyun banate hain?

Java me best practice ye hai ki class ke fields hamesha private rakhe jayein — iska reason Encapsulation (OOP principle) hai 👇

@RestController
public class DemoController {
    public Coach myCoach;  // ❌ Dangerous

    @GetMapping("/dailyworkout")
    public String getDailyWorkout() {
        return myCoach.getDailyWorkout();
    }
}


@RestController
public class DemoController {

    // ✅ This is a private FIELD (not an interface)
    private Coach myCoach;

    // ✅ Constructor Injection
    @Autowired
    public DemoController(Coach theCoach) {
        myCoach = theCoach;
    }

    @GetMapping("/dailyworkout")
    public String getDailyWorkout() {
        return myCoach.getDailyWorkout();
    }
}


1. Class ke field ka matlab kya hota hai?

👉 Field ka matlab hota hai: variables jo class ke andar declare kiye jaate hain (but kisi method ke andar nahi).
Inhe hum instance variables ya member variables bhi kehte hain.simple 


🧠 Step 1: Spring kis cheez ko inject karta hai?

Spring sirf usi class का object inject करता है jo Spring container ke andar bean ke रूप में register होती है।

और bean बनने के लिए class के ऊपर hum likhte hain:

@Component

@Service

@Repository

@Controller / @RestController

👉 Tumhare example me:

@Component
class CricketCoach implements Coach {  ✅ Bean ban gaya
    public String getDailyWorkout() {
        return "Practice fast bowling for 15 minutes!";
    }
}


✅ Yaha CricketCoach ko Spring ne bean bana diya — matlab Spring container uska object bana ke store karega.

🧠 Step 2: Constructor injection me type dekh ke inject hota hai

Jab tum constructor me likhte ho:

public DemoController(Coach theCoach) {   // 👈 yeh Coach type maang raha hai
    myCoach = theCoach;
}


Spring dekhta hai: “DemoController banane ke liye mujhe ek Coach type ka object chahiye.”

Phir wo container me search karta hai: “Kya koi class hai jo Coach interface implement karti hai aur bean hai?”

Spring ko milta hai 👇

@Component
class CricketCoach implements Coach { ... }


✅ Bingo! Yehi class Coach implement karti hai aur bean bhi hai.
Isliye Spring iska object bana ke theCoach me inject kar deta hai.

🧠 Step 3: Agar ek se zyada implementation mile to?

Agar tumhare paas 2 classes ho:

@Component
class CricketCoach implements Coach {...}

@Component
class FootballCoach implements Coach {...}


Toh ab Spring confuse ho jayega:
"Kaunsa inject karun? CricketCoach ya FootballCoach?"

❌ Error aayega: NoUniqueBeanDefinitionException

✅ Solution: Use @Qualifier

@Autowired
public DemoController(@Qualifier("cricketCoach") Coach theCoach) {
    myCoach = theCoach;
}


Ab Spring specifically CricketCoach inject karega.

🧠 Step 4: Tumhe kaise pata chalega ki kya inject hoga?

Shortcut sochne ka tarika 👇

Type check karo: Constructor me jo type likha hai (yaha Coach), Spring usi type ka bean dhundhega.

Bean check karo: Kya koi class hai jo us type ko implement karti hai aur @Component ya similar annotation laga hai?

✅ Agar 1 hi class milti hai → Spring wahi inject karega.

⚠️ Agar multiple classes milti hain → @Qualifier lagana padega.

❌ Agar koi class hi nahi milti → NoSuchBeanDefinitionException aayega.

🔎 Ek chhota diagram soch lo:
Interface: Coach
      ↑
      │
      └── CricketCoach ( @Component ) ✅ Bean


👉 Spring ne dekha: Coach type chahiye → CricketCoach implement karta hai → Inject kar do!

✅ Short and Simple Rule:

Jis type ki dependency tum constructor (ya field) me maang rahe ho, Spring usi type ka bean container me dhundta hai. Agar ek mil gaya → wahi inject karega.

💡 Tip: Tum @Component class ka naam aur interface type dekh ke hamesha predict kar sakte ho ki Spring kya inject karega.


1. @Configuration kya hai?

👉 @Configuration ek annotation hai jo Spring ko batata hai ki ye class ek configuration class hai —
matlab iske andar hum Spring Beans manually define karenge (Java code ke through), bina @Component ke.

🔎 Simple definition:

@Configuration lagane ka matlab hai — “Yeh class Spring container ke liye bean definitions contain karti hai.”

📦 2. Kahaan use karte hain?

Jab tumhe beans manually banana ho.

Jab tum @Component ya @Service ki jagah code se bean create karna chahte ho.

Jab tum beans ke behavior customize karna chahte ho.

✅ 3. Basic Example
@Configuration
public class SportConfig {

    @Bean
    public Coach cricketCoach() {
        return new CricketCoach();
    }
}


📌 Explanation:

@Configuration → Batata hai ki SportConfig ek configuration class hai.

@Bean → Batata hai ki cricketCoach() ka return value (CricketCoach object) ek bean hai jisko Spring container manage karega.


🌱 1. @SpringBootApplication class kya karti hai?

@SpringBootApplication wali class tumhare Spring Boot project ki entry point hoti hai —
matlab Java program wahi se start hota hai:

public static void main(String[] args) {
    SpringApplication.run(CruddemoApplication.class, args);
}


🔎 Ye line:

Spring Boot application start karti hai

Spring container (IoC) ko initialize karti hai

Saare @Component, @Service, @Repository etc. beans ko scan aur load karti hai

Aur project ko run kar deti hai 🚀



persist ka use JPA / Hibernate me hota hai — ye ek method hai jo hum EntityManager ke through use karte hain, aur iska kaam hota hai:

👉 Database me naya record insert karna (save karna)

📌 Syntax:
entityManager.persist(entityObject);


entityManager → JPA ka object hai jo database ke sath interact karta hai.

entityObject → Wo object hai jo aapne kisi @Entity class se banaya hai (jaise Student, Employee, etc.).


🔍 ObjectMapper Java me ek class hai jo Jackson library ka part hai, aur iska kaam hota hai —

👉 Java objects ko JSON me convert karna aur
👉 JSON ko Java objects me convert karna.

Yaani simple shabdon me:

Java ➝ JSON (Serialization)

JSON ➝ Java (Deserialization)



public Employee patchEmployee(@PathVariable int employeeId,
                              @RequestBody Map<String , Object> patchPayLoad)
1️⃣ public
This is an access modifier.

Means this method can be accessed from anywhere, even from other classes or packages.

2️⃣ Employee
This is the return type of the method.

It tells Java that this method will return an Employee object.

Employee is likely a class in your project representing an employee.

3️⃣ patchEmployee
This is the name of the method.

You can call it anything, but here it describes what the method does: patching/updating an employee.

4️⃣ ( and )
Parentheses enclose the parameters the method needs to work.

5️⃣ @PathVariable
This is a Spring annotation.

It tells Spring: “Hey, get this value from the URL path”.

Example: URL → /employee/5 → employeeId will be 5.

6️⃣ int employeeId
int → data type (integer).

employeeId → variable name representing the ID of the employee we want to patch.

So combining @PathVariable int employeeId → take the employee ID from the URL.

7️⃣ @RequestBody
Another Spring annotation.

Tells Spring: “The request body (JSON sent from client) should be converted into this variable.”

8️⃣ Map<String, Object> patchPayLoad
This is the parameter type and name.

Breaking it down:

Map → a collection of key-value pairs.

<String, Object> → the keys are strings (like "firstName", "salary") and values can be any type (Object) because it could be String, Integer, etc.

patchPayLoad → variable name holding the data sent by the client in the request body.

Example JSON request:

json
Copy code
{
  "firstName": "Azeem",
  "salary": 50000
}
This will be converted into a Map with keys "firstName" and "salary".

✅ Putting it all together
Method is public → can be accessed from anywhere.

Returns an Employee object.

Name of the method is patchEmployee.

Takes two inputs:

employeeId → from URL path (e.g., /employee/5)

patchPayLoad → from request body (JSON) with fields to update

This method is usually used in PATCH HTTP requests to partially update an employee.
